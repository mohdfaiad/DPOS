{ RRRRRR                  ReportBuilder Class Library                  BBBBB
  RR   RR                                                              BB   BB
  RRRRRR                 Digital Metaphors Corporation                 BB BB
  RR  RR                                                               BB   BB
  RR   RR                   Copyright (c) 1996-2004                    BBBBB   }

unit ppFilDev;

interface

{$I ppIfDef.pas}

uses
  {$IFDEF Delphi6} RTLConsts, {$ENDIF}
  Windows, Classes, Consts, Graphics, ExtCtrls, SysUtils, Forms, Controls, 
  ppDevice, ppTypes, ppUtils, ppForms, ppDrwCmd;


type

  {@TppStreamDevice

     This class is an abstract ancestor for stream based report output
     formats. TppStreamDevice descends from TppDevice and adds
     functionality required to manage an output stream.

     Assign the value of the OutputStream property to redirect output to a
     custom stream that is created and destroyed outisde of this class.

     TppFileDevice extends TppStreamDevice to add functionality required to
     manage a file stream.}

  {@TppStreamDevice.OutputStream

    Provides access to the output stream. Set this property to redirect output
    to a custom stream that is created and destroyed outside of this class.}

  TppStreamDevice = class(TppDevice)
    private
      FOutputStream: TStream;
      FFreeingStream: Boolean;

      procedure InternalFreeOutputStream;

    protected
      function CreateOutputStream: TStream; virtual; abstract;
      procedure FreeOutputStream; virtual; abstract;

      procedure SetOutputStream(Value: TStream); virtual;
      procedure WriteToOutputStream(const Buffer; Count: Longint); virtual;

    public
      constructor Create(aOwner: TComponent); override;
      destructor Destroy; override;

      procedure EndJob; override;
      procedure StartJob; override;
      procedure CancelJob; override;

      property OutputStream: TStream read FOutputStream write SetOutputStream;

  end;


  {@TppFileDevice

     This class is an abstract ancestor class for report output formats that are
     printed to a file. Registered FileDevices appear in the PrintDialog under
     the filetypes drop down list. TppFileDevice descends from TppStreamDevice
     and adds functionality that supports writing to filestream.

     This class supports the two types of stream based output:

      - Set FileName to specify the name of the output file. The FileDevice will
        internally create a FileStream and assign it to the OutputStream property.
      - Set the OutputStream property to redirect output to a custom stream
        that is created and destroyed externally.}

  {@TppFileDevice.FileName

    Set FileName to specify the name of the output file.}

  {@TppFileDevice.FileStream

    Retained for backward compatibility. Use the OutputStream property to access
    the output stream.}


  TppFileDevice = class(TppStreamDevice)
    private
      FAutoOpen: Boolean;
      FFileName: String;
      FFileStream: TFileStream;

    protected
      function CreateOutputStream: TStream; override;
      procedure FreeOutputStream; override;
      function CreateFileStream: TStream; virtual;
      procedure DisplayMessage(aPage: TppPage); virtual;
      procedure SetFileName(aFileName: String); virtual;
      procedure SetAutoOpen(aValue: Boolean); virtual;

      procedure WriteToFileStream(const Buffer; Count: Longint);  virtual;

    public
      constructor Create(aOwner: TComponent); override;
      destructor Destroy; override;

      class function DefaultExt: String; virtual;  {abstract;  removed to support CBuilder}
      class function DefaultExtFilter: String; virtual;  {abstract;  removed to support CBuilder}
      class function DeviceDescription(aLanguageIndex: Longint): String; virtual;  {abstract;  removed to support CBuilder}

      procedure EndJob; override;
      procedure StartJob; override;

      property FileName: String read FFileName write SetFileName;
      property FileStream: TFileStream read FFileStream;

  end; {class TppFileDevice}

  {@TppTextFileDevice

    This component receives the pages generated by the report engine and saves
    the textual portions to a file. To access this component, typecast the
    Sender parameter of any textual component OnSave event. Use the StartingLine
    and EndingLine properties to add custom formatting to each line. Use the
    StartingPage and EndingPage properties to add custom formatting to each
    page. Use the FirstLine and LastLine properties to add formatting to the
    beginning or ending of the file.  The text file is opened when the Publisher
    calls the StartJob method. Text file is closed when the Publisher calls the
    EndJob method. If the Publisher calls the CancelJob method the file is
    closed and deleted.

    An example of an event handler utilizing these properties has been
    provided.}

  {@TppTextFileDevice.EndingLine

    Run-time only. Indicates that the last item of the line is being written to
    the file.}

  {@TppTextFileDevice.EndingPage

    Run-time only. Indicates that the last item of the page is being written to
    the file.}

  {@TppTextFileDevice.FirstLine

    Run-time only. Indicates that the first line is being written to the file.}

  {@TppTextFileDevice.LastLine

    Run-time and read-only. Indicates that the last line is being written to the
    file.}

  {@TppTextFileDevice.LineItemNo

    Run-time and read-only. This property maintains a count as each item is
    added to the line.}

  {@TppTextFileDevice.LineNo

    Run-time and read-only. This item maintains a count as each line is written
    to the file.}

  {@TppTextFileDevice.StartingLine

    Run-time and read-only. Indicates that the first item of the line is being
    written to the file.}

  {@TppTextFileDevice.StartingPage

    Run-time and read-only. Indicates that the last item of the line is being
    written to the file.}

  {@TppTextFileDevice.TextFileType

    The TextFileType property determines format of the file when printing to a
    text file.

    <Table>
    Value              Meaning
    --------------     ---------
    ftComma	           Comma delimited file
    ftTab	             Tab delimited file.
    ftFixedLength      Fixed Length records, each textual component is saved
                       with the length specified in the SaveLength property.
    ftCustom	         No delimiters or carriage return line-feeds are provided.
                       The textual components are streamed together unless you
                       use the OnSave event to add formatting.
    </Table>}

  TppTextFileDevice = class(TppFileDevice)
    private
      FEndingLine: Boolean;
      FEndingPage: Boolean;
      FFirstLine: Boolean;
      FLineItemNo: Longint;
      FLineNo: Longint;
      FLastLine: Boolean;
      FOnSave: TppTextDeviceSaveEvent;
      FStartingLine: Boolean;
      FStartingPage: Boolean;
      FTextFileType: TppFileType;

      procedure GetDrawTextCommands(aPage: TppPage; aList: TStringList);
      procedure SavePageToFile(aPage: TppPage);
      procedure SetTextFileType(aFileType: TppFileType);

    public
      constructor Create(aOwner: TComponent); override;

      class function DeviceName: String; override;
      class function DefaultExt: String; override;
      class function DefaultExtFilter: String; override;
      class function DeviceDescription(aLanguageIndex: Longint): String; override;

      procedure StartJob; override;
      procedure ReceivePage(aPage: TppPage); override;
      procedure EndJob; override;

      property EndingLine: Boolean read FEndingLine;
      property EndingPage: Boolean read FEndingPage;
      property FirstLine: Boolean read FFirstLine;
      property LineItemNo: Longint read FLineItemNo;
      property LineNo: Longint read FLineNo;
      property LastLine: Boolean read FLastLine;
      property OnSave: TppTextDeviceSaveEvent read FOnSave write FOnSave;
      property StartingLine: Boolean read FStartingLine;
      property StartingPage: Boolean read FStartingPage;
      property TextFileType: TppFileType read FTextFileType write SetTextFileType default ftComma;

  end; {class TppTextFileDevice}


  {@TppReportTextFileDevice

    This device saves all of the text from the report to the text file specified
    in the TextFileName property. The positions of the textual components are
    converted to a character grid before being placed into the file (much like the
    Generic/TextOnly driver).  In order to get good looking text files using this
    device, modifications to the report layout are usually required.  This is due
    to the factthat the precise positions of the text on the page do not always
    convert well to the crudecharacter grid positions required by a text file.  An
    example of a report layout that has been modified for printing to file is
    provided in demo 107.

    Note: The difference between this device and the TextFileDevice is that the
    TextFileDevice is best at generating structured text files (with column headers
    and 'fields') that can be easily imported into spreadsheets or other
    applications designed to handle tabular data.  The purpose of
    ReportTextFileDevice is to emulate the format of the report in the text.}

  {@TppReportTextFileDevice.AutoCalcGrid

    When set to True this property forces the device to automatically calculate
    the character grid based on the font of the first textual component rendered
    for the page. Typical character grid values include 120 characters wide by
    66 lines and 80 characters wide by 66 lines.}

  {@TppReportTextFileDevice.CharsPerLine

    Run-time and read-only. This property returns the characters per line of the
    character grid.}

  {@TppReportTextFileDevice.LinesPerPage

    Run-time and read-only. This property returns the lines per page of the
    character grid.}

  TppReportTextFileDevice = class(TppFileDevice)
    private
      FAutoCalcGrid: Boolean;
      FCalculateOutputFontSize: Boolean;
      FCharsPerLine: Integer;
      FLinesPerPage: Integer;
      FOutputFontSize: Integer;

      procedure GetDrawTextCommands(aPage: TppPage; aList: TStringList);
      procedure SavePageToFile(aPage: TppPage);
      procedure SetOutputFontSize(Value: Integer);

    public
      constructor Create(aOwner: TComponent); override;

      {override from TppFileDevice}
      class function DeviceName: String; override;
      class function DefaultExt: String; override;
      class function DefaultExtFilter: String; override;
      class function DeviceDescription(aLanguageIndex: Longint): String; override;

      {override from TppDevice}
      procedure ReceivePage(aPage: TppPage); override;

      procedure CharacterGrid(aCharsPerLine, aLinesPerPage: Integer);

      property AutoCalcGrid: Boolean read FAutoCalcGrid write FAutoCalcGrid;
      property CalculateOutputFontSize: Boolean read FCalculateOutputFontSize write FCalculateOutputFontSize default True;
      property CharsPerLine: Integer read FCharsPerLine;
      property LinesPerPage: Integer read FLinesPerPage;
      property OutputFontSize: Integer read FOutputFontSize write SetOutputFontSize;

  end; {class TppReportTextFileDevice}

  {@TppArchiveDevice
  
   This component receives the pages generated by the report engine and saves
   them to a file.}

  TppArchiveDevice = class(TppFileDevice)
    private
      FPageStream: TFileStream;
      FTempFile: String;

      FSaveCompleteOutlineOnly: Boolean;

      procedure FreeOutlineDrawCommand(aPage: TppPage);
      procedure SavePageToFile(aPage: TppPage);

    public
      constructor Create(aOwner: TComponent); override;

      class function DeviceName: String; override;
      class function DefaultExt: String; override;
      class function DefaultExtFilter: String; override;
      class function DeviceDescription(aLanguageIndex: Longint): String; override;

      procedure StartJob; override;
      procedure ReceivePage(aPage: TppPage); override;
      procedure EndJob; override;

      property SaveCompleteOutlineOnly: Boolean read FSaveCompleteOutlineOnly write FSaveCompleteOutlineOnly;

  end; {class TppArchiveDevice}


  TppFileDeviceClass = class of TppFileDevice;

implementation

{x$DEFINE TESTING}

{$IFDEF TESTING}
{------------------------------------------------------------------------------}
{ BinaryStreamToTextStream}

function BinaryStreamToTextStream(aBinaryStream: TStream): TMemoryStream;
var
  lDecimalSeparator: Char;

begin

  lDecimalSeparator := DecimalSeparator;

  Result := TMemoryStream.Create;

  try
    {convert & copy binary BinaryStream content to TextStream }
    aBinaryStream.Seek(0, soFromBeginning);

    DecimalSeparator  := '.';

    ObjectBinaryToText(aBinaryStream, Result);

    DecimalSeparator := lDecimalSeparator;

  except

    DecimalSeparator := lDecimalSeparator;

    Result.Free;

    raise

  end;

end;

{$ENDIF}


{******************************************************************************
 *
 ** S T R E A M   D E V I C E
 *
{******************************************************************************}

{------------------------------------------------------------------------------}
{ TppStreamDevice.Create }

constructor TppStreamDevice.Create(aOwner: TComponent);

begin
  inherited Create(aOwner);

  FOutputStream := nil;

end; {constructor, Create}

{------------------------------------------------------------------------------}
{ TppStreamDevice.Destroy }

destructor TppStreamDevice.Destroy;
begin

  {EndJob, if needed}
  if Busy then
    EndJob;

  inherited Destroy;

end; {destructor, Destroy}

{------------------------------------------------------------------------------}
{ TppStreamDevice.InternalFreeOutputStream }

procedure TppStreamDevice.InternalFreeOutputStream;
begin

  if not(FFreeingStream) then
    begin
      FFreeingStream := True;
      try
        FreeOutputStream;
      finally
        FFreeingStream := False;
      end;
    end;

end;

{------------------------------------------------------------------------------}
{ TppStreamDevice.SetOutputStream }

procedure TppStreamDevice.SetOutputStream(Value: TStream);
begin
  // free the existing stream
  if (FOutputStream <> nil) then
    InternalFreeOutputStream;

  FOutputStream := Value;

end;

{------------------------------------------------------------------------------}
{ TppStreamDevice.StartJob }

procedure TppStreamDevice.StartJob;
begin
  inherited StartJob;

  if (FOutputStream = nil) then
    FOutputStream := CreateOutputStream;

end; {procedure, StartJob}

{------------------------------------------------------------------------------}
{ TppStreamDevice.EndJob }

procedure TppStreamDevice.EndJob;
begin
  inherited EndJob;

  if (FOutputStream <> nil) then
    InternalFreeOutputStream;

end; {procedure, EndJob}

{------------------------------------------------------------------------------}
{ TppStreamDevice.CancelJob }

procedure TppStreamDevice.CancelJob;
begin
  inherited CancelJob;

  if (FOutputStream <> nil) then
    InternalFreeOutputStream;

end; {procedure, CancelJob}

{------------------------------------------------------------------------------}
{ TppStreamDevice.WriteToOutputStream }

procedure TppStreamDevice.WriteToOutputStream(const Buffer; Count: Longint);
begin

  if (Count <> 0) and (FOutputStream <> nil) and (FOutputStream.Write(Buffer, Count) <> Count) then
{$IFDEF Delphi5}
    raise EWriteError.CreateRes(PResStringRec(@SWriteError));
{$ELSE}
    raise EWriteError.Create(SWriteError);
{$ENDIF}
end; {procedure, WriteToFileStream}



{******************************************************************************
 *
 ** F I L E   D E V I C E
 *
{******************************************************************************}

{------------------------------------------------------------------------------}
{ TppFileDevice.Create }

constructor TppFileDevice.Create(aOwner: TComponent);

begin
  inherited Create(aOwner);

  FAutoOpen := True;
  FFileName   := '';
  FFileStream := nil;

end; {constructor, Create}

{------------------------------------------------------------------------------}
{ TppFileDevice.Destroy }

destructor TppFileDevice.Destroy;
begin

  inherited Destroy;

end; {destructor, Destroy}

{------------------------------------------------------------------------------}
{ TppFileDevice.DefaultExt }

class function TppFileDevice.DefaultExt: String;
begin
  {treat as abstract - descendants should override}
  Result := '';

end; {class function, DefaultExt}

{------------------------------------------------------------------------------}
{ TppFileDevice.DefaultExtFilter }

class function TppFileDevice.DefaultExtFilter: String;
begin
  {treat as abstract - descendants should override}
  Result := '';

end; {class function, DefaultExtFilter}

{------------------------------------------------------------------------------}
{ TppFileDevice.DeviceDescription }

class function TppFileDevice.DeviceDescription(aLanguageIndex: Longint): String;
begin
  {treat as abstract - descendants should override}
  Result := '';

end; {class function, DeviceDescription}


{------------------------------------------------------------------------------}
{ TppFileDevice.SetFileName }

procedure TppFileDevice.SetFileName(aFileName: String);
begin

  if not(Busy) then
    FFileName := aFileName;

end; {procedure, SetTextFileName}


{------------------------------------------------------------------------------}
{ TppFileDevice.CreateOutputStream }

function TppFileDevice.CreateOutputStream;
begin

  Result := CreateFileStream;

end;

{------------------------------------------------------------------------------}
{ TppFileDevice.FreeOutputStream }

procedure TppFileDevice.FreeOutputStream;
begin

  // only free the streams that we create
  if (FFileStream <> nil) then
    begin
      if OutputStream = FFileStream then
        OutputStream := nil;

      FFileStream.Free;
      FFileStream := nil;
    end;

end;

{------------------------------------------------------------------------------}
{ TppFileDevice.CreateFileStream }

function TppFileDevice.CreateFileStream: TStream;
var
  lMode: Word;
  lsMessage: String;
begin

  if (FAutoOpen) then
    begin

      lMode := fmOpenReadWrite or fmShareExclusive or fmCreate;

      {put exception handling here in case file can't be opened}
      try
        FFileStream := TFileStream.Create(FFileName, lMode);
      except
        lsMessage := ppLoadStr(67); {Unable to open file: <filename>.}
        lsMessage := ppSetMessageParameters(lsMessage);
        lsMessage := Format(lsMessage, [FFileName]);

        raise EPrintError.Create(lsMessage);
      end; {try, except}

    end; {if FAutoOpen}

  Result := FFileStream;

end;

{------------------------------------------------------------------------------}
{ TppFileDevice.StartJob }

procedure TppFileDevice.StartJob;
begin
  // ancestor will call create stream
  inherited StartJob;

  DisplayMessage(nil);

end; {procedure, StartJob}

{------------------------------------------------------------------------------}
{ TppFileDevice.EndJob }

procedure TppFileDevice.EndJob;
begin
  // anscestor will call free stream
  inherited EndJob;

end; {procedure, EndJob}

{------------------------------------------------------------------------------}
{ TppFileDevice.DisplayMessage }

procedure TppFileDevice.DisplayMessage(aPage: TppPage);
var
  lsMessage: String;
begin

  if (aPage = nil) then
    begin
      {message: Accessing data...}
      lsMessage := ppLoadStr(2);
    end

  else if IsMessagePage and ((Publisher <> nil) and not Publisher.ReportCompleted) then
    begin

      if (CancelDialog <> nil) then
        lsMessage := CancelDialog.PrintProgress
      else
        lsMessage := '';

    end
  else if (PageRequest.PageSetting = psAll) and (aPage.PassSetting = psTwoPass) then
    begin
      {message: Printing Page 1 of 15 for <reportname> on <printername>}
      lsMessage := ppLoadStr(28);
      lsMessage := ppSetMessageParameters(lsMessage);
      lsMessage := Format(lsMessage, [IntToStr(aPage.AbsolutePageNo), IntToStr(aPage.AbsolutePageCount),
                          aPage.DocumentName, FileName]);

    end

  else
    begin
      {message: Printing Page 1 for <reportname> on <printername>}
      lsMessage := ppLoadStr(27);
      lsMessage := ppSetMessageParameters(lsMessage);
      lsMessage := Format(lsMessage, [IntToStr(aPage.AbsolutePageNo), aPage.DocumentName,
                                      FileName]);
    end;

  if (CancelDialog <> nil) and (CancelDialog.PrintProgress <> lsMessage) then
    begin
      CancelDialog.PrintProgress := lsMessage;
      Application.ProcessMessages;
    end;

end; {procedure, DisplayMessage}

{------------------------------------------------------------------------------}
{ TppFileDevice.SetAutoOpen }

procedure TppFileDevice.SetAutoOpen(aValue: Boolean);
begin

  if (FAutoOpen <> aValue) then
    FAutoOpen := aValue;

end; {procedure, SetAutoOpen}

{------------------------------------------------------------------------------}
{ TppFileDevice.WriteToFileStream
  - retained for backward compatibility}

procedure TppFileDevice.WriteToFileStream(const Buffer; Count: Longint);
begin

  WriteToOutputStream(Buffer, Count);

end; {procedure, WriteToFileStream}


{******************************************************************************
 *
 ** T E X T   F I L E   D E V I C E
 *
{******************************************************************************}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.Create }

constructor TppTextFileDevice.Create(aOwner: TComponent);

begin
  inherited Create(aOwner);

  FEndingLine := False;
  FFirstLine := False;
  FLineItemNo := 0;
  FLineNo := 0;
  FLastLine := False;
  FOnSave := nil;
  FStartingLine := False;
  FTextFileType := ftComma;

end; {constructor, Create}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.DeviceName }

class function TppTextFileDevice.DeviceName: String;
begin
  Result := 'TextFile';
end; {class function, DeviceName}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.DefaultExt }

class function TppTextFileDevice.DefaultExt: String;
begin
  Result := 'txt';
end; {class function, DefaultExt}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.DefaultExtFilter }

class function TppTextFileDevice.DefaultExtFilter: String;
begin
  Result := 'Text files|*.TXT|All files|*.*';
end; {class function, DefaultExtFilter}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.DeviceDescription }

class function TppTextFileDevice.DeviceDescription(aLanguageIndex: Longint): String;
begin
  Result := ppLoadStr(37);
end; {class function, DeviceDescription}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.SetTextFileType }

procedure TppTextFileDevice.SetTextFileType(aFileType: TppFileType);
begin

  if not(Busy) then
    FTextFileType := aFileType;

end; {procedure, SetTextFileType}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.StartJob }

procedure TppTextFileDevice.StartJob;
begin
  inherited StartJob;

  FEndingLine := False;
  FEndingPage := False;
  FFirstLine := False;
  FLineItemNo := 0;
  FLineNo := 0;
  FLastLine := False;
  FStartingLine := False;
  FStartingPage := False;

end; {procedure, StartJob}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.EndJob }

procedure TppTextFileDevice.EndJob;
begin
  FEndingLine := False;
  FEndingPage := False;
  FFirstLine := False;
  FLineItemNo := 0;
  FLineNo := 0;
  FLastLine := False;
  FStartingLine := False;
  FStartingPage := False;

  inherited EndJob;

end; {procedure, EndJob}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.ReceivePage }

procedure TppTextFileDevice.ReceivePage(aPage: TppPage);
begin

  inherited ReceivePage(aPage);

  if (IsRequestedPage) then
    begin
      DisplayMessage(aPage);

      if not(IsMessagePage) then
        SavePageToFile(aPage);
    end;

end; {procedure, ReceivePage}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.SavePageToFile }

procedure TppTextFileDevice.SavePageToFile(aPage: TppPage);
var
  liCommand      : Integer;
  liCommands     : Integer;
  lDrawCommands  : TStringList;
  lDrawText      : TppDrawText;
  lsLine         : String;
  lsText         : String;
  liBandNo       : Longint;
  liSaveBandNo   : Longint;
  liLastBandNo   : Longint;
  lsDelimiter    : String;
  lsCRLF         : String;
  lsSaveLine     : String;

  procedure EndLine;
    begin
      lsSaveLine := lsLine;

      {write line to stream}
      if (Length(lsSaveLine) > 0) then
          begin
            WriteToFileStream(lsSaveLine[1], Length(lsSaveLine));

            {if not end of file, add carriage return to end of line}
            if not((aPage.LastPage) and FEndingPage) and
               not(FTextFileType = ftCustom) then
              WriteToFileStream(lsCRLF[1], Length(lsCRLF));
          end;

    end; {procedure, EndLine}

begin


  lsCRLF := #13#10;

  {get the draw text commands from the page}
  lDrawCommands := TStringList.Create;

  GetDrawTextCommands(aPage, lDrawCommands);

  if (lDrawCommands.Count = 0) then
    begin
      lDrawCommands.Free;

      Exit;
    end;

  {sort the commands into proper order}
  lDrawCommands.Sort;

  {get delimiter}
  case FTextFileType of
    ftComma:
      lsDelimiter := ',';

    ftTab:
      lsDelimiter := #9;

    else
      lsDelimiter := '';
  end;

  {init looping vars}
  liCommand := 0;
  liCommands := lDrawCommands.Count;

  FStartingPage := True;
  FEndingPage := False;

  FFirstLine := (aPage.AbsolutePageNo = 1);
  liLastBandNo := TppDrawText(lDrawCommands.Objects[liCommands - 1]).BandSaveNo;

  {loop through canvas commands, saving values to text file}
  while (liCommand < liCommands) do
    begin

      FLineItemNo := 0;

      FStartingLine := True;
      FEndingLine := False;

      lsLine := '';

      lDrawText := TppDrawText(lDrawCommands.Objects[liCommand]);

      liBandNo := lDrawText.BandSaveNo;
      liSaveBandNo := liBandNo;

      FLastLine := (aPage.LastPage) and (liBandNo = liLastBandNo);

      while (liBandNo = liSaveBandNo) do
        begin

          {set ending line, ending page indicators}
          if (liCommand = (liCommands - 1)) then
            begin
              FEndingLine := True;
              FEndingPage := True;
            end

          else if (liBandNo <> TppDrawText(lDrawCommands.Objects[liCommand + 1]).BandSaveNo) then
            FEndingLine := True;

          {get the text value}
          lsText := lDrawText.Text;

          {if fixed length, truncate or pad text as necessary}
          if (FTextFileType = ftFixedLength) then
            lsText := ppFixText(lsText, lDrawText.SaveLength, lDrawText.Alignment);

          if (FTextFileType = ftComma) and ((Pos(',', lsText) <> 0) or (Pos(#32, lsText) <> 0)) then
            lsText := '"' + lsText + '"';

          {fire the OnSave event}
          if Assigned(FOnSave) then FOnSave(Self, lDrawText.Component, lsText);

          if FStartingPage then
            FStartingPage := False;

          {add delimiter to text value}
          if FStartingLine then
            FStartingLine := False
          else
            lsText := lsDelimiter + lsText;

          lsLine := lsLine + lsText;

          Inc(FLineItemNo);

          Inc(liCommand);

          if (liCommand >= liCommands) then
            liBandNo := -1

          else
            begin
              lDrawText := TppDrawText(lDrawCommands.Objects[liCommand]);

              liBandNo := lDrawText.BandSaveNo;
            end;

      end; {while, line not complete}

      {save completed line to file}
      EndLine;

      if FFirstLine then
        FFirstLine := False;

      Inc(FLineNo);

    end; {while, each command}


    lDrawCommands.Free;

end; {procedure, SavePageToFile}

{------------------------------------------------------------------------------}
{ TppTextFileDevice.GetDrawTextCommands }

procedure TppTextFileDevice.GetDrawTextCommands(aPage: TppPage; aList: TStringList);
var
  liCommand: Integer;
  liCommands: Integer;
  lCommand: TppDrawCommand;
  lDrawText: TppDrawText;
begin

  {retrieve draw text commands which need to be saved to file}
  liCommands := aPage.DrawCommandCount;

  for liCommand := 0 to liCommands - 1 do
    begin

      lCommand := aPage.DrawCommands[liCommand];

      if (lCommand is TppDrawText) then
        begin
          lDrawText := TppDrawText(lCommand);

          if lDrawText.BandSave and lDrawText.ComponentSave then
            aList.AddObject(lDrawText.Order, lDrawText);

        end;

    end;

end; {procedure, GetDrawTextCommands}

{******************************************************************************
 *
 ** A R C H I V E   D E V I C E
 *
{******************************************************************************}


{------------------------------------------------------------------------------}
{ TppArchiveDevice.Create }

constructor TppArchiveDevice.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);

  FPageStream := nil;

  { for deployment purposes this should be true. for QA this should be false
    in order to test the incremental outline generation }
  FSaveCompleteOutlineOnly := True;

end; {constructor, Create}

{------------------------------------------------------------------------------}
{ TppArchiveDevice.DeviceName }

class function TppArchiveDevice.DeviceName: String;
begin
  Result := 'ArchiveFile';
end; {class function, DeviceName}


{@TppArchiveDevice.DefaultExt
 The DefaultExt property controls the default extension used when this device
 creates a file.

 Note: When the user is printing to file, a 'File' button is displayed on the
 Print dialog. This button allows the user to access a standard Delphi
 TSaveDialog. This dialog allows the user to specify the file to which the
 report should be printed. The DefaultExt and DefaultExtFilter functions are
 assigned to this dialog before it is displayed.}

class function TppArchiveDevice.DefaultExt: String;
begin
  Result := 'raf';
end; {class function, DefaultExt}


{@TppArchiveDevice.DefaultExtFilter
 The DefaultExtFilter property controls the files that will be listed in the
 current directory. For example, the filter: 'Text files|*.TXT' would display
 all files with the extension 'txt' in the current directory.

 Note: When the user is printing to file, a 'File' button is displayed on the
 Print dialog. This button allows the user to access a standard Delphi
 TSaveDialog. This dialog allows the user to specify the file to which the
 report should be printed. The DefaultExt and DefaultExtFilter functions are
 assigned to this dialog before it is displayed.}

class function TppArchiveDevice.DefaultExtFilter: String;
begin
  Result := 'Archive files|*.RAF|All files|*.*';
end; {class function, DefaultExtFilter}


{@TppArchiveDevice.DeviceDescription
 This function is used to populate the drop-down list of devices on the File tab
 of the Print dialog, and should return a more user-friendly description of the
 device than the DeviceName function. For example, the new ReportTextFileDevice
 class returns 'Report Emulation Text File' as the DeviceDescription and
 'ReportTextFile' as the DeviceName.}

class function TppArchiveDevice.DeviceDescription(aLanguageIndex: Longint): String;
begin
  Result := ppLoadStr(34); {'Archive File'}
end; {class function, DeviceDescription}

{------------------------------------------------------------------------------}
{ TppArchiveDevice.StartJob }

procedure TppArchiveDevice.StartJob;
var
  lMode: Word;
  lsMessage: String;
begin

  inherited StartJob;

  lMode := fmCreate or fmShareExclusive;

  FTempFile := ppGetTempFileName(ppGetTempPath, 'arc');

  {put exception handling here in case file can't be opened}
  try
    FPageStream := TFileStream.Create(FTempFile, lMode);

  except
    lsMessage := ppLoadStr(67); {Unable to open file: <filename>.}
    lsMessage := ppSetMessageParameters(lsMessage);
    lsMessage := Format(lsMessage, [FTempFile]);

    raise EPrintError.Create(lsMessage);
  end; {try, except}


  {save a space in the front of the stream to write the page directory size}
  OutputStream.Position := SizeOf(Longint);

end; {procedure, StartJob}

{------------------------------------------------------------------------------}
{ TppArchiveDevice.EndJob }

procedure TppArchiveDevice.EndJob;
var
  llPageDirectorySize: Longint;
begin

  if OutputStream = nil then Exit;

  llPageDirectorySize := OutputStream.Position;

  {copy pagestream to output stream,
    note: pass 0 as second paramter to copy entire stream}
  OutputStream.CopyFrom(FPageStream, 0);

  {write the page directory size}
  OutputStream.Position := 0;
  WriteToFileStream(llPageDirectorySize, SizeOf(llPageDirectorySize));

  FPageStream.Free;
  FPageStream := nil;

  {delete the temp file}
  DeleteFile(FTempFile);

  inherited EndJob;

end; {procedure, EndJob}


{------------------------------------------------------------------------------}
{ TppArchiveDevice.ReceivePage }

procedure TppArchiveDevice.ReceivePage(aPage: TppPage);
begin

  inherited ReceivePage(aPage);

  if (IsRequestedPage) then
    begin
      DisplayMessage(aPage);

      if not(IsMessagePage) then
        SavePageToFile(aPage);
    end;

end; {procedure, ReceivePage}

{------------------------------------------------------------------------------}
{ TppArchiveDevice.SavePageToFile }

procedure TppArchiveDevice.SavePageToFile(aPage: TppPage);
var
  lPageEntry: TppPageEntryRec;
begin

  if (not(aPage.LastPage) and FSaveCompleteOutlineOnly) then
    FreeOutlineDrawCommand(aPage);

  lPageEntry.Position       := FPageStream.Position;
  lPageEntry.AbsolutePageNo := aPage.AbsolutePageNo;

  try

    {write the page directory}
    WriteToFileStream(lPageEntry, SizeOf(lPageEntry));

    {write the page }
    FPageStream.WriteComponent(aPage);

  except on E: EWriteError do
    begin
      FreeOutputStream;

      FPageStream.Free;
      FPageStream := nil;

      DeleteFile(FTempFile);

      raise E;
    end;
  end;

end; {procedure, SavePageToFile}

{------------------------------------------------------------------------------}
{ TppArchiveDevice.FreeOutlineDrawCommand }

procedure TppArchiveDevice.FreeOutlineDrawCommand(aPage: TppPage);
var
  lOutlineDrawCommand: TppDrawCommand;
begin

  lOutlineDrawCommand := aPage.GetOutlineDrawCommand;

  if (lOutlineDrawCommand <> nil) then
    begin
      lOutlineDrawCommand.Page := nil;
      lOutlineDrawCommand.Free;
    end;

end; {procedure, FreeOutlineDrawCommand}

{******************************************************************************
 *
 ** R E P O R T   T E X T   F I L E   D E V I C E
 *
{******************************************************************************}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.Create }

constructor TppReportTextFileDevice.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);

  FAutoCalcGrid := True;
  FCalculateOutputFontSize := True;
  FCharsPerLine := 80;
  FLinesPerPage := 66;
  FOutputFontSize := 12;

end; {constructor, Create}

{@TppReportTextFileDevice.CharacterGrid
 Sets the character grid used to convert the positions of the textual components
 of each report page to the character position within the text file.  The
 character grid is usually calculated automatically based on the first textual
 component rendered (when AutoCalcGrid is set to True).  Manually modifying the
 grid can sometimes improve the quality of the resulting text file; however,
 changing the report layout itself is usually the quickest way to a create a
 text file that most accurately reflects the report.}

procedure TppReportTextFileDevice.CharacterGrid(aCharsPerLine, aLinesPerPage: Integer);
begin
  FAutoCalcGrid := False;

  FCharsPerLine := aCharsPerLine;
  FLinesPerPage := aLinesPerPage;

end; {procedure, CharacterGrid}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.DeviceName }

class function TppReportTextFileDevice.DeviceName: String;
begin
  Result := 'ReportTextFile';
end; {class function, DeviceName}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.DefaultExt }

class function TppReportTextFileDevice.DefaultExt: String;
begin
  Result := 'txt';
end; {class function, DefaultExt}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.DefaultExtFilter }

class function TppReportTextFileDevice.DefaultExtFilter: String;
begin
  Result := 'Text files|*.TXT|All files|*.*';
end; {class function, DefaultExtFilter}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.DeviceDescription }

class function TppReportTextFileDevice.DeviceDescription(aLanguageIndex: Longint): String;
begin
  Result := ppLoadStr(12); {'Report Emulation Text File'}
end; {class function, DeviceDescription}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.ReceivePage }

procedure TppReportTextFileDevice.ReceivePage(aPage: TppPage);
begin

  inherited ReceivePage(aPage);

  if (IsRequestedPage) then
    begin
      DisplayMessage(aPage);

      if not(IsMessagePage) then
        SavePageToFile(aPage);
    end;

end; {procedure, ReceivePage}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.SavePageToFile }

procedure TppReportTextFileDevice.SavePageToFile(aPage: TppPage);
var
  lDrawCommands: TStringList;
  lDrawText: TppDrawText;
  liCommand: Integer;
  lsCRLF: String;
  lsLine: String;
  liCharPos: Integer;
  liLineNo: Integer;
  llTextWidth: Longint;
  llTextHeight: Longint;
  lsText: String;

  function TopToLineNo(aTop: Longint): Integer;
  begin
    Result := (aTop div llTextHeight) + 1;
  end;

  function LeftToCharPos(aLeft: Longint): Integer;
  begin
    Result := (aLeft div llTextWidth) + 1;
  end;

  function JustifyText: String;
  var
    liLength: Integer;
    liWidth: Integer;
  begin
    Result := lDrawText.Text;

    liWidth := (lDrawText.Width div llTextWidth) + 1;

    if (lDrawText.AutoSize) then
      begin
        liLength := Length(lDrawText.Text);

        if (liLength < liWidth) then
          liLength := liWidth;
      end
    else
      liLength := liWidth;

    Result := ppFixText(Result, liLength, lDrawText.Alignment);
  end;

  function BlankLine: String;
  var
    liIndex: Integer;
  begin
    Result := '';

    for liIndex := 1 to FCharsPerLine do
      Result := Result + ' ';
  end;

  function GetNearestCourierSize(aFont: TFont): Integer;
  var
    lBitmap: TBitmap;
    liTextWidth8: Integer;
    liTextWidth10: Integer;
    liTextWidthAFont: Integer;
  begin
    {Default to Courier New 12}
    Result := 12;

    lBitmap := TBitmap.Create;
    try
      lBitmap.Canvas.Font.Name := 'Courier New';
      lBitmap.Canvas.Font.Size := 8;
      liTextWidth8 := lBitmap.Canvas.TextWidth('0');

      lBitmap.Canvas.Font.Size := 10;
      liTextWidth10 := lBitmap.Canvas.TextWidth('0');

      lBitmap.Canvas.Font := aFont;
      liTextWidthAFont := lBitmap.Canvas.TextWidth('0');

      if liTextWidthAFont <= liTextWidth8 then
        Result := 8
      else if liTextWidthAFont <= liTextWidth10 then
        Result := 10;

    finally
      lBitmap.Free;
    end;
  end;

  procedure CalcCharacterGrid;
  var
    lDrawCommand: TppDrawCommand;
    lBitmap: TBitmap;
    lDrawText: TppDrawText;
    liTextWidth: Integer;
    liTextHeight: Integer;
    liFontSize: Integer;
  begin

    lBitmap := TBitmap.Create;

    liTextWidth := 0;
    liTextHeight := 0;

    try

      lBitmap.Canvas.TryLock;

      lDrawCommand := TppDrawCommand(lDrawCommands.Objects[0]);

      if not(lDrawCommand is TppDrawText) then
        raise EReportBuilderError.Create('procedure TppReportTextFileDevice.CalcCharacterGrid: Drawcommand is not a TppDrawText but a ' + lDrawCommand.ClassName);

      lDrawText := TppDrawText(lDrawCommand);

      if CalculateOutputFontSize then
        liFontSize := GetNearestCourierSize(lDrawText.Font)
      else
        liFontSize := OutputFontSize;

      lBitmap.Canvas.Font.Name := 'Courier New';
      lBitmap.Canvas.Font.Size := liFontSize;

      liTextWidth := lBitmap.Canvas.TextWidth('0');
      liTextHeight := lBitmap.Canvas.TextHeight('0');

    finally
      lBitmap.Canvas.UnLock;

      lBitmap.Free;
    end;

    if FAutoCalcGrid then
      begin
        llTextWidth := Round(ppFromScreenPixels(liTextWidth, utMMThousandths, pprtHorizontal, nil));
        llTextHeight := Round(ppFromScreenPixels(liTextHeight, utMMThousandths, pprtVertical, nil));

        FCharsPerLine := (aPage.PageDef.mmWidth div llTextWidth);
        FLinesPerPage := (aPage.PageDef.mmHeight div llTextHeight);
      end
    else
      begin
        llTextWidth := (aPage.PageDef.mmWidth div FCharsPerLine);
        llTextHeight := (aPage.PageDef.mmHeight div FLinesPerPage);
      end;

  end;

  procedure EndLine;
  begin

    lsLine := TrimRight(lsLine);

    {write line to stream}
    if (Length(lsLine) > 0) then
      WriteToFileStream(lsLine[1], Length(lsLine));

    {if not end of file, add carriage return to end of line}
    if (liLineNo = FLinesPerPage) and (aPage.LastPage) then
      {do nothing}
    else
      WriteToFileStream(lsCRLF[1], Length(lsCRLF));

    Inc(liLineNo);

  end; {procedure, EndLine}

begin

  lsCRLF := #13#10;

  {get the draw text commands from the page}
  lDrawCommands := TStringList.Create;

  try
    GetDrawTextCommands(aPage, lDrawCommands);

    if (lDrawCommands.Count > 0) then
      begin
        {sort the commands into proper order}
        lDrawCommands.Sort;

        {calculate character grid}
        CalcCharacterGrid;

        {init looping vars}
        liCommand := 0;
        lsLine := BlankLine;
        liLineNo := 1;

        {loop through canvas commands, saving values to text file}
        while (liCommand < lDrawCommands.Count) and (liLineNo <= FLinesPerPage) do
          begin
            lDrawText := TppDrawText(lDrawCommands.Objects[liCommand]);

            if (TopToLineNo(lDrawText.Top) = liLineNo) then
              begin
                liCharPos := LeftToCharPos(lDrawText.Left);

                lsText := JustifyText;

                Delete(lsLine, liCharPos, Length(lsText));
                Insert(lsText, lsLine, liCharPos);

                Inc(liCommand);
              end
            else
              begin
                EndLine;

                lsLine := BlankLine;
              end;

          end; {while, each command}

        while (liLineNo <= FLinesPerPage) do
          begin
            EndLine;

            lsLine := BlankLine;
          end;
      end;
  finally
    lDrawCommands.Free;
  end;

end; {procedure, SavePageToFile}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.SetOutputFontSize }
procedure TppReportTextFileDevice.SetOutputFontSize(Value: Integer);
begin

  if (Value <> FOutputFontSize) then
    begin
      FOutputFontSize := Value;
      FCalculateOutputFontSize := False;
    end;

end; {procedure, SetOutputFontSize}

{------------------------------------------------------------------------------}
{ TppReportTextFileDevice.GetDrawTextCommands }

procedure TppReportTextFileDevice.GetDrawTextCommands(aPage: TppPage; aList: TStringList);
var
  liCommand: Integer;
  liCommands: Integer;
  lCommand: TppDrawCommand;
  lDrawText: TppDrawText;
  lsOrder: String;
  lBitmap: TBitmap;
  liIndex: Integer;
  liTop: Integer;
  liTextHeight: Integer;
  lMemo: TppDrawText;
begin

  lBitmap := nil;

  try

    {retrieve draw text commands which need to be saved to file}
    liCommands := aPage.DrawCommandCount;

    for liCommand := 0 to liCommands - 1 do
      begin

        lCommand := aPage.DrawCommands[liCommand];

        if (lCommand is TppDrawText) then
          begin
            if (TppDrawText(lCommand).WrappedText.Count > 0) then
              begin
                lMemo := TppDrawText(lCommand);

                if (lBitmap = nil) then
                  lBitmap := TBitmap.Create;

                lBitmap.Canvas.Font := lMemo.Font;
                liTextHeight := lBitmap.Canvas.TextHeight('0');
                liTextHeight := Round(ppFromScreenPixels(liTextHeight, utMMThousandths, pprtVertical, nil));
                liTop := lMemo.Top;
                
                for liIndex := 0 to lMemo.WrappedText.Count - 1 do
                  begin
                    lDrawText := TppDrawText.Create(Self);
                    lDrawText.Text := lMemo.WrappedText[liIndex];
                    lDrawText.Font := lMemo.Font;
                    lDrawText.Color := lMemo.Color;
                    lDrawText.Height := liTextHeight;
                    lDrawText.Left := lMemo.Left;
                    lDrawText.Top := liTop;
                    lDrawText.Width := lMemo.Width;
                    lDrawText.Alignment := lMemo.Alignment;
                    liTop := liTop + liTextHeight;
                    lsOrder := Format('%8d',[lDrawText.Top]) + Format('%8d',[lDrawText.Left]);
                    aList.AddObject(lsOrder, lDrawText);
                  end;
              end
            else
              begin
                lDrawText := TppDrawText(lCommand);
                lsOrder := Format('%8d',[lDrawText.Top]) + Format('%8d',[lDrawText.Left]);
                aList.AddObject(lsOrder, lDrawText);
              end;
          end;

      end;

  finally
    lBitmap.Free;
  end;

end; {procedure, GetDrawTextCommands}

{******************************************************************************
 *
 ** I N I T I A L I Z A T I O N   /   F I N A L I Z A T I O N
 *
{******************************************************************************}



initialization

  ppRegisterDevice(TppTextFileDevice);
  ppRegisterDevice(TppReportTextFileDevice);
  ppRegisterDevice(TppArchiveDevice);

finalization

  ppUnRegisterDevice(TppTextFileDevice);
  ppUnRegisterDevice(TppReportTextFileDevice);
  ppUnRegisterDevice(TppArchiveDevice);

end. 
